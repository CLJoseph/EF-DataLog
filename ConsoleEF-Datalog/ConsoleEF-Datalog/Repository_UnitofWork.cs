using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace EFCoreRepositoryDatalog
{
    public interface IRepositoryUnitofWork : IDisposable
    {
        bool Complete();
    }
    public class RepositoryUnitofWork : IRepositoryUnitofWork
    {
        private readonly ApplicationDbContext _context;
        public RepositoryUnitofWork(ApplicationDbContext Context)
        {
            _context = Context;
            Lookup = new RepositoryTLookup(_context);
            People = new RepositoryTPerson(_context);
            Addresses = new RepositoryTAddress(_context);
            DBLog = new RepositoryTDBLog(_context);
        }

        public IRepositoryLookup  Lookup    { get; private set; }
        public IRepositoryPerson  People    { get; private set; }
        public IRepositoryAddress Addresses { get; private set; }
        public IRepositoryTDBLog  DBLog     { get; private set; }

        public bool Complete()
        {
            try
            {
                GetChanges();
                _context.SaveChanges();
                return true;
            }
            catch (DbUpdateException Ex )
            {  
                Console.WriteLine("Error :" + Ex.Message);
                Console.WriteLine("Error :" + Ex.InnerException.ToString());

                return false;
            }
            catch (Exception Ex)
            {
                Console.WriteLine("Error :" + Ex.Message + " Detail :" + Ex.InnerException.InnerException.Message);
                return false;
            }
        }
        public void Dispose()
        {
            _context.Dispose();
        }

        public void GetChanges()
        {
            // inspects the context and records changes into DBlog 
            List<T_DbLog> AllChanges = new List<T_DbLog>();
            foreach(var Item in _context.ChangeTracker.Entries())
            {
                if (Item.Entity is T_DbLog || Item.State == EntityState.Detached || Item.State == EntityState.Unchanged)
                {
                    continue;
                }
                T_DbLog change = new T_DbLog();
                change.LogDateTime = DateTime.Now;
                change.TableName = Item.Metadata.Relational().TableName;
                switch (Item.State)
                {
                    case EntityState.Added:
                        change.Event = "Added";                      
                        break;
                    case EntityState.Deleted:
                        change.Event = "Deleted";
                        break;
                    case EntityState.Modified:
                        change.Event = "Modified";
                        break;
                }
                foreach (var Prop in Item.Properties)
                {
                    if (Prop.IsTemporary)
                    {
                        // value will be generated by the database, for this situation Ignore it
                        continue;
                    }
                    // table column name
                    string PropName = Prop.Metadata.Name;
                    if (Prop.Metadata.IsPrimaryKey())
                    {
                        change.TablePKName = PropName;
                        change.TablePKValue = Prop.CurrentValue.ToString();
                        // move on to next property
                        continue;
                    }

                    if (Prop.Metadata.IsForeignKey())
                    {
                        var S = " FK :" + PropName + ":" + Prop.CurrentValue.ToString();
                        change.TableForeignKeys = change.TableForeignKeys + S;
                        // move on to next property
                        continue;
                    }
                    change.Detail = change.Detail + PropName + ":" + Prop.CurrentValue.ToString() + " ";
                }
                AllChanges.Add(change);
            }

            // now add the changes recorded to the db context 
            _context.AddRange(AllChanges);

        }
    }
}
